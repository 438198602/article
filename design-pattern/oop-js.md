# 面向对象的JavaScript

‘工欲善其事，必先利其器’，在学习研究JavaScript设计模式之前，我认为我们很有必要了解以下，JavaScript这门面向对象的动态语言到底是一门什么样的语言。

## JavaScript vs 其他面向对象语言

* 它没有使用像Java等传统的面向对象语言的类式继承，而是通过原型委托的方式来实现对象间的继承；
* 它没有在语言层面提供对抽象类和接口的支持；
* 动态类型语言（它可以让开发者将更多的精力放在业务逻辑上，代码量更少；但它由于无法确定变量的类型，从而使程序可能发生一些与类型相关的错误）
 
动态类型语言对变量类型的宽容，给实际编码带来了很大的灵活性。由于无需进行类型的检测，我们可以尝试调用任何对象的任何方法，而无需考虑它原本是否设计有该方法。

说到这里，我们就不得不提一下` 鸭子类型 `。

注：` 鸭子类型 `就说只关注对象的行为，而不关注对象本身。

我们知道JavaScript是面向接口编程的语言，而非是面向实现编程的。因此只要我们给对象添加pop，push方法，增添length属性，那么这个对象就可以当数组使用。

虽然，JavaScript是面向接口的语言，但是它和静态类型语言的面向接口编程不一样。

## 面向对象语言的特性

面向对象包括：

* 封装。数据的权限和保密
* 继承。子类继承父类
* 多态。同一接口的不同实现

### 封装

封装的目的是将信息隐藏。

封装包括数据的封装、实现的封装和变化的封装。

1.数据的封装

在js中我们只能依赖变量的作用域来进行封装。可以实现全局作用域和局部作用域，在ES6之前我们使用函数来创建作用域，但在之后我们也可用let来创建作用域。

2.实现的封装

实现的封装使得对象的内部变化对其他对象来说是不可见的。对象对它自己的行为负责，其它对象不关心它的内部实现。

封装使得对象间的耦合变得松散，对象间只能通过暴露的API接口进行通信，只要我们不修改对象的对外接口，怎么样修改对象都不会影响其它对象的功能。

3.变化的封装

它就是将应用中稳定的部分和变化的部分隔离开来。如果我们将变化的部分封装起来，那么在应用的开发中我们将很容易的实现替换。这样可以最大程度的保证应用的稳定性和可扩展性。

### 多态

它将可变的部分与不可变的部分分离开来，吧可变的部分封装起来（对象拥有相同的类型，都有相同的方法，接受相同的调用，却返回不同的结果）

下面是一个对象的多态：
	
```
var robotA = {
	dance: function() {
		console.log('robtA')
	}
};

var robotB = {
	dance: function() {
		console.log('robtB')
	}
}

var robotAction = function(robot) {
	if(robot.dance instanceof Function)
	robot.dance()
}

robotAction(robotA); // robtA
robotAction(robotB); // robtB
```

在JavaScript中函数被当作第一等对象，也即是说函数本身也是对象，我们知道因为js是动态类型语言，所以函数不仅可以用来封装行为，并且可以被当作参数四处传递。当我们对函数发起调用时，函数会返回不同的结果，这是多态的一种体现，也是很多设计模式能被高阶函数代替实现的原因。

## 原型继承和原型设计模式

前面我们已经说过JavaScript没有类式继承，取而代之的是原型的继承，这是语言的开发者根本就没打算在js中引入类这个概念，而是引入了原型的概念。

在原型的编程思想中对象是通过复制而来的，克隆而来的对象与原对象看不出什么区别。

说到克隆对象，在ES5中有一个Object.create()方法来实现克隆，这个方法有兼容性问题，如果要在只支持ES3的浏览器中这就有一个问题。我们一般用下面的代码来解决：

```
Object.create = Object.create || function(obj) {
	var F = function() {};
	F.prototype = obj;
	return new F()
}
```

在js这种类型模糊的语言中，创建对象很容易，也不存在类型耦合的情况。

js中的对象的实现是通过js的原型系统来实现的，前面也说过在js中一切皆对象，所以要想很好的掌握js就要认真研究一下它的原型。

根据JavaScript的设计者本意，除了undefined之外的所有数据都是对像，我们知道js中的对象都是通过原型克隆而来的的，而在js中对象为Object，所以数据都是通过Object.prototype而来的（Object对象克隆自Function）。示例代码如下：

```
var animal = { name: 'lzb' }; 
var person = function(){};
person.prototype = animal;
var lzb = new person();
console.log( lzb.name ); // lzb
```

其实严格意义上来说实现对象的构造器有原型，如果对象的请求无响应，对象把它的请求委托给它的构造器的原型。

## 原型继承有未来吗

这个在网上说法不一，有的人认为原型继承很烂，并且说既然人们总结出了JavaScript的设计模式，而模式的出现本身就意味着语言的不足。但是，有的人认为它在未来相当长的一段时间还是有市场的，并且js本身就在自我矫正，用一些新的特性来代替设计模式，ES5中的Object.create()来代替原型模式克隆对象，而ES6中的class的引入也是这个原因，虽然其背后的实现还是原型来克隆对象，但它的出现的确解决了一定的问题。再加上现在开发人员对它的兴趣大增，所以我认为原型继承有未来。

好了，今天的基础回顾就到这里，顺便我们了解了以下原型设计模式，原型模式的地位很重要，它和js的原型继承一脉相承。
